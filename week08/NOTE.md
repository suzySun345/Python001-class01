#### 学习笔记

------

**容器序列**：list、tuple、collections.deque

**扁平序列**：str、bytes、bytearray、memoryview、array.array

**容器序列可以存放不同类型的数据。即可以存放任意类型对象的引用。**

**扁平序列只能容纳一种类型。也就是说其存放的是值而不是引用**。扁平序列其实是一段连续的内存空间，由此可见扁平序列其实更加紧凑。但是它里面只能存放诸如**字符、字节和数值**这种基础类型。

**可变序列**： list，bytearray，array.array，collections.deque和memoryview(内存视图) 

**不可变序列**： tuple，str和bytes

**可变序列就是创建一个序列后，可以改变元素、元素位置**

**不可变序列就是序列一旦创建后，就不可以修改了，对于基础数据类型，变量地址即变量本身，所以值发生变化了，内存地址就一定也变了。**



**函数** 

------

函数在Python是第一类对象 

第一类对象的特性：

1. 可以被引用

2. 可以作为参数传递给其他函数

3. 可以作为函数的返回值

4. 可以当做容器类型的元素被存储入变量或其他结构

   函数名加括号是调用函数，不加括号是在操作函数，指向内存地址

5. 可以在执行期创造，而无需完全在设计期全部写出

**变量作用域**：以 L –> E –> G –>B 的规则查找，也就是在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找再者去内建中找

1. 局部作用域 L (Local)：最先搜索的最内部作用域包含局部名称
2. 嵌套作用域 E (Enclosing) ：最近封闭作用域开始搜索的任何封闭函数的作用域
3. 全局作用域 G (Global)：倒数第二个作用域包含当前模块的全局名称
4. 内置作用域 B (Built-in)：最外面的作用域（最后搜索）包含内置名称的命名空间

**lambda表达式**： 冒号前是参数，可以有多个，用逗号隔开，冒号右边的返回值。lambda语句构建的其实是一个函数对象 lambda [arg1[,arg2,arg3....argN]]:expression

**偏函数**： functools.partial() 将所要承载的函数作为partial()函数的第一个参数,partial 的第二个参数是原函数的第一个参数

**高级函数** 

------

常见的高阶函数：map、reduce、filter

**map**函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。

**reduce**把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算

**filter**也接收一个函数和一个序列。filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素

**sorted**函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序

**装饰器** 

1. 装饰器语法糖 python提供了@符号作为装饰器的语法糖，使用语法糖要求装饰函数必须return一个函数对象。因此我们将上面的func函数使用内嵌函数包裹并return

2. 对带参数的函数进行装饰 @decorate def bar(): print('i am bar:%s'%(a+b)) bar(1,2)
   等价于： decorate(target)(1,2)

3. 函数参数数量不确定 装饰器内使用变长参数*args和**kwargs

4. 装饰器带参数 装饰器带上参数

5. functools.wraps 如果想要保留原函数的属性，就可以用到functools.wraps

**参数传递**

- 赋值参数
- 默认参数
  1. 默认参数在定义函数时定义
  2. 调用时如果没有传递参数则会使用默认参数
  3. 默认参数只会执行一次（在默认值为可变对象时很重要）
- 关键字参数
  1. 使用形参来确定输入的参数值且必须跟在位置参数后 1.1 *arg：把多出的位置参数转化为元组 1.2 **kwarg：把关键字参数转化为字典
  2. 调用时以 kwarg=value 的形式来指定 2.1 * 解包元组 2.2 ** 解包字典





